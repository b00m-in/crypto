package util

import (
	"crypto/x509"
        "encoding/pem"
        "fmt"
        "io/fs"
        "io/ioutil"
        //"path/filepath"
        "strings"
        "time"
)

type X509Info struct {
        Sni string
        Rsa bool
}

//CheckExpiry is a filepath.WalkFunc which skips over directories and private keys and verifies x509 certificates for expiry. It returns any non-nil error generated by filepath.Walk provided as argument to it and only returns a non-nil error itself with the DNSName of the certificate when it encounters an expired x509 certificate.
func CheckExpiry(path string, info fs.FileInfo, err error) error {
        if err != nil {
                fmt.Printf("prevent panic by handling failure accessing a path %q: %v\n", path, err)
                return err
        }

        if info.IsDir()  {
                // skip over directories
                fmt.Printf("skipping a dir without errors: %+v \n", info.Name())
                //return filepath.SkipDir
        } else {
                if strings.Contains(info.Name(), "key.pem") {

                } else {
                        //pub, err := x509.ParsePKIXPublicKey(block.Bytes)
                        fmt.Printf("checking cert %s \n", path)
                        cert, err := PEM2DERCert(path)
                        if err != nil {
                                fmt.Printf("couldn't parse certificate %v \n", err)
                                return err
                        }
                        //fmt.Printf("%v - %v \n", pub.Issuer, pub.Subject)
                        if cert.NotAfter.Before(time.Now().AddDate(0,0,+10)) {
                                if len(cert.DNSNames) > 0 {
                                        if cert.PublicKeyAlgorithm == x509.RSA {
                                                return fmt.Errorf("%s=%d", cert.DNSNames[0], cert.PublicKeyAlgorithm)
                                        }
                                        return fmt.Errorf("%s", cert.DNSNames[0])
                                }
                        }
                        //If the certificate has less than 2 days to expiry return err with dns
                        /*vo := x509.VerifyOptions{CurrentTime: time.Now().AddDate(0, 0, -2)}
                        _, err = cert.Verify(vo)
                        if err != nil {
                                fmt.Printf("%s: %v\n" , path, err)
                                if strings.Contains(err.Error(), "certificate has expired") && len(cert.DNSNames) > 0 {
                                        return fmt.Errorf("%s", cert.DNSNames[0])
                                }
                                //return err
                        } else {
                                //fmt.Printf("%v \n", chains)
                        }*/
                        /*switch pt := pub.(type){
                        case *rsa.PublicKey:
                                fmt.Println("pub is of type RSA:", pt)
                        case *dsa.PublicKey:
                                fmt.Println("pub is of type DSA:", pt)
                        case *ecdsa.PublicKey:
                                fmt.Println("pub is of type ECDSA:", pt)
                        case ed25519.PublicKey:
                                fmt.Println("pub is of type Ed25519:", pt)
                        default:
                        fmt.Println("unknown type of public key")

                        }*/
                }
        }
        return nil
}

func CheckSignatureFrom(leaf, root string) error {
        lc, err := PEM2DERCert(leaf)
        if err != nil {
                return err
        }
        rc, err := PEM2DERCert(root)
        if err != nil {
                return err
        }
        if err := lc.CheckSignatureFrom(rc); err != nil {
                return err
        }
        return nil
}

func PEMBytes2DERCert(bs []byte) (*x509.Certificate, error) {
        block, _ := pem.Decode(bs)
        if block == nil {
                return nil, fmt.Errorf("%s\n", "pem decode block is nil")
        }

        dc, err := x509.ParseCertificate(block.Bytes)
        if err != nil {
                return nil, err
        }
        return dc, nil
}

func PEM2DERCert(path string) (*x509.Certificate, error) {
        bs, err := ioutil.ReadFile(path)
        if err != nil {
                return nil, err
        }

        block, _ := pem.Decode(bs)
        if block == nil {
                return nil, fmt.Errorf("%s\n", "pem decode block is nil")
        }

        dc, err := x509.ParseCertificate(block.Bytes)
        if err != nil {
                return nil, err
        }
        return dc, nil
}

func PEM2Bytes(path string) ([]byte, error) {
        var fb []byte
        fb, err := ioutil.ReadFile(path)
        if err != nil {
                return fb, err
        }
        return fb, nil
        /*pb, _ := pem.Decode(fb)
        if pb == nil {
                return fb, fmt.Errorf("%s\n", " pem decode block is nil")
        }
        return pb.Bytes, nil*/
}

func DNSNameFromPEMBytes(bs []byte) string {

        cert, err := PEMBytes2DERCert(bs)
        if err != nil {
                fmt.Printf("%v %v\n", err, bs)
                return ""
        }
        if cert != nil && len(cert.DNSNames) > 0 {
                return cert.DNSNames[0]
        }
        return ""

}
